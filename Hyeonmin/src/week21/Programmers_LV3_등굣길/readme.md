## Programmers Lv3 등굣길
- DP
- level3

<br>


### 🔍 문제 설명
https://programmers.co.kr/learn/courses/30/lessons/42898

가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.

격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.


#### 제한사항
격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
물에 잠긴 지역은 0개 이상 10개 이하입니다.
집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.

<br><br>

###  💡 풀이

변수
`int[][] dp` : 각 좌표까지 오는 경로의 수를 저장할 2차원 배열


<br>

어느 좌표 위치의 경로의 수에 영향을 주는 값은 그 좌표보다 왼쪽에 있으면서 위쪽에 있는 경우들 뿐이다
그래서 왼쪽열부터 세로방향으로의 경로의 수를 계속해서 구해주면 각 위치로 갈 수 있는 최단 경로를 구할 수 있다

우선 웅덩이가 있는 곳을 -1로 저장하고 집이 있는 위치의 최단 경로 수를 1로 저장한다

```java
        //집이있는 위치
        dp[1][1] = 1;
```

제일 왼쪽 열부터 차례대로 아래 좌표에 도달하는 최단 경로수를 구한다
좌표위치의 `dp`배열값이 -1인 경우 그 이후에 도달하는 위치들의 최단경로 수에 영향을 주면 안되므로경로가 0인 것으로 취급한다
`dp`값이 -1이 아닌 경우 정상 경로이므로 그 좌표의 왼쪽과 위쪽의 `dp`값을 더해 저장한다

```java
        for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				//집이 있는 위치는 다음위치로 바로 이동
				if(i==1 && j==1)
					continue;
				
				//웅덩이가 있는 경우는 그 이후 경로에 영향을 주면 안되므로 0으로 변경
				if(dp[i][j] == -1) {
					dp[i][j] = 0;
				}
				//현재 위치까지 오는 최단 경로의 수는 현재 위치의 왼쪽과 위쪽까지 오는 최단 경로의 수의 합이다
				else {
					dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % 1000000007;
				}
			}
		}
```


<br><br>

###  💡 소스코드
```java
public class Programmers_LV3_등굣길 {
	public static void main(String[] args) {
		int m = 4;
		int n = 3;
		
		int[][] puddles = {{2,2}};
		
		System.out.println(solution(m,n,puddles));

	}
	
	static int solution(int m, int n, int[][] puddles) {
        int[][] dp = new int[101][101];
        
        //웅덩이가 있는 곳을 -1로 표시
        for(int[] arr : puddles){
            dp[arr[0]][arr[1]] = -1;
        }
        
        //집이있는 위치
        dp[1][1] = 1;
        
        for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				//집이 있는 위치는 다음위치로 바로 이동
				if(i==1 && j==1)
					continue;
				
				//웅덩이가 있는 경우는 그 이후 경로에 영향을 주면 안되므로 0으로 변경
				if(dp[i][j] == -1) {
					dp[i][j] = 0;
				}
				//현재 위치까지 오는 최단 경로의 수는 현재 위치의 왼쪽과 위쪽까지 오는 최단 경로의 수의 합이다
				else {
					dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % 1000000007;
				}
			}
		}
        
        int answer = dp[n][m] % 1000000007;
        return answer;
	}

}



```


<br>


정확성  테스트
테스트 1 〉	통과 (0.05ms, 52.8MB)
테스트 2 〉	통과 (0.07ms, 53.3MB)
테스트 3 〉	통과 (0.07ms, 52.8MB)
테스트 4 〉	통과 (0.06ms, 52.3MB)
테스트 5 〉	통과 (0.07ms, 53.3MB)
테스트 6 〉	통과 (0.06ms, 52.5MB)
테스트 7 〉	통과 (0.06ms, 52.3MB)
테스트 8 〉	통과 (0.08ms, 52.3MB)
테스트 9 〉	통과 (0.06ms, 53.4MB)
테스트 10 〉	통과 (0.06ms, 54.1MB)
효율성  테스트
테스트 1 〉	통과 (0.69ms, 53MB)
테스트 2 〉	통과 (0.26ms, 52.3MB)
테스트 3 〉	통과 (0.35ms, 52.7MB)
테스트 4 〉	통과 (0.54ms, 52.3MB)
테스트 5 〉	통과 (0.47ms, 52.2MB)
테스트 6 〉	통과 (0.72ms, 53.2MB)
테스트 7 〉	통과 (0.36ms, 53MB)
테스트 8 〉	통과 (0.49ms, 52.9MB)
테스트 9 〉	통과 (0.56ms, 51.9MB)
테스트 10 〉	통과 (0.53ms, 52.9MB)